import numpy as np
import matplotlib.pyplot as plt

def c(theta): return np.cos(np.radians(theta))
def s(theta): return np.sin(np.radians(theta))

a1, a2, a3 = 5, 4, 3

def compute_positions(theta1, theta2, theta3):
    H1 = np.array([
        [-s(theta1), 0,  c(theta1), a1*c(theta1)],
        [ c(theta1), 0,  s(theta1), a1*s(theta1)],
        [0,           1, 0,          0],
        [0,           0, 0,          1]
    ])

    H2 = np.array([
        [ c(theta2), -s(theta2), 0, a2*c(theta2)],
        [ s(theta2),  c(theta2), 0, a2*s(theta2)],
        [0,            0,        1, 0],
        [0,            0,        0, 1]
    ])

    H3 = np.array([
        [ c(theta3), -s(theta3), 0, a3*c(theta3)],
        [ s(theta3),  c(theta3), 0, a3*s(theta3)],
        [0,            0,        1, 0],
        [0,            0,        0, 1]
    ])

    T1 = H1
    T2 = H1 @ H2
    T3 = T2 @ H3

    O0 = np.array([0, 0, 0])
    O1 = T1[:3, 3]
    O2 = T2[:3, 3]
    O3 = T3[:3, 3]
    return np.array([O0, O1, O2, O3])

def cubic_path(a, b, t, steps=100):
    l1, l2, l3 = [], [], []
    for j in range(steps + 1):
        i = (t / steps) * j
        theta1 = a[0] + (3*(b[0]-a[0]) / t**2) * i**2 - (2*(b[0]-a[0]) / t**3) * i**3
        theta2 = a[1] + (3*(b[1]-a[1]) / t**2) * i**2 - (2*(b[1]-a[1]) / t**3) * i**3
        theta3 = a[2] + (3*(b[2]-a[2]) / t**2) * i**2 - (2*(b[2]-a[2]) / t**3) * i**3
        l1.append(theta1)
        l2.append(theta2)
        l3.append(theta3)
    return l1, l2, l3

print("Enter 4 points (x y z):")
points = []
for i in range(4):
    coords = input(f"Point {i+1}: ").split()
    x, y, z = map(float, coords)
    points.append((x, y, z))

print("\nEnter 4 theta positions (θ1 θ2 θ3):")
theta1 = list(map(float, input("Theta 1: ").split()))
theta2 = list(map(float, input("Theta 2: ").split()))
theta3 = list(map(float, input("Theta 3: ").split()))
theta4 = list(map(float, input("Theta 4: ").split()))

t12 = float(input("Time for θ1 → θ2: "))
t23 = float(input("Time for θ2 → θ3: "))
t34 = float(input("Time for θ3 → θ4: "))
t41 = float(input("Time for θ4 → θ1: "))

p12 = cubic_path(theta1, theta2, t12)
p23 = cubic_path(theta2, theta3, t23)
p34 = cubic_path(theta3, theta4, t34)
p41 = cubic_path(theta4, theta1, t41)

theta1_list = p12[0] + p23[0] + p34[0] + p41[0]
theta2_list = p12[1] + p23[1] + p34[1] + p41[1]
theta3_list = p12[2] + p23[2] + p34[2] + p41[2]

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
ax.set_title("3-Link Robotic Leg Simulation with Input Points")
ax.view_init(elev=90, azim=-90)

for x, y, z in points:
    ax.scatter(x, y, z, s=60, c='red')

reach = a1 + a2 + a3
ax.set_xlim([-reach, reach])
ax.set_ylim([-reach, reach])
ax.set_zlim([-reach/2, reach])  

ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")

pos = compute_positions(theta1_list[0], theta2_list[0], theta3_list[0])
(line,) = ax.plot(pos[:, 0], pos[:, 1], pos[:, 2], '-o', lw=3, c='royalblue')

eff_text = ax.text2D(0.05, 0.95, "", transform=ax.transAxes, fontsize=12, color='darkred')

plt.ion()
plt.show()

try:
    while True:
        for k in range(len(theta1_list)):
            if not plt.fignum_exists(fig.number):
                raise KeyboardInterrupt
            pos = compute_positions(theta1_list[k], theta2_list[k], theta3_list[k])
            line.set_data(pos[:, 0], pos[:, 1])
            line.set_3d_properties(pos[:, 2])

            eff_text.set_text(f"End-Effector: X={pos[-1,0]:.2f}, Y={pos[-1,1]:.2f}, Z={pos[-1,2]:.2f}")

            plt.pause(0.02)
except KeyboardInterrupt:
    plt.close()
    print("Simulation closed.")

